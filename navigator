#!/bin/bash  

# опции
# t - типы файлов, которые должны входить в список. Можно инвертировать указав "^" в начале. Каждый тип перечислен одним символом. Возможные значения - "dl-bcps"
# p - начальный каталог (путь)
# n - часть имени, файлы с которым должны входить в список. НУЖНО ЗАКЛЮЧАТЬ В ""!!!
# r - корень файлового дерева.
# e - команда перед выводом списка. Можно запихнуть сюда lsblk и прочее
# E - команда после выбора файла. Выполняется в теле скрипта, не нужно из него выходить.
# b - блокировка hl
# h - подсказки
# f,F - выбранный файл (короткий и полный вид)
# d,D - текущая директория(короткий и полный вид) + разделитель 
# c,C - вид курсора (короткий и длинный)
# N - нумерация строк
# s,S - сортировка по времени и размеру

function FList(){
    ls $1 "$2" | sed -r "/^[$3].*"${PART_NAME}".*$/"'!d'";s|^.*\"(.*)\"$|$5\1|" | sed -r "/${4:-.*}/"'!d'
}

while getopts "t:p:n:r:e:E:bhfFd:D:cCNsS" OPTION; do
 case $OPTION in
    t)
      F_TYPE="${OPTARG}";;
    p)
      PATH_DIR="${OPTARG}";;
    n)
      PART_NAME="${OPTARG}";;
    r)
      ROOT_DIR="${OPTARG}";;
    e)
      COMMAND_BEFOR="${OPTARG}";;
    E)
      COMMAND_AFTER="$(OPTARG)";;
    b)
      BLOCK_HL=1;;
    h)
      HELP='[j]down   [k]up   [h]back   [l]forward   [/]search   [s]select file   [q]reset search/quit';;
    f)
      F_SELECTED='selected file: ${R}${SELECTED_FILE}${NC}';;
    F)
#@ проконтролировать для корня
      F_SELECTED='selected file: ${R}${SELECTED_FILE##*/}${NC}';;
    d)
      CURRENT_DIR='$(echo "${PREF}${R}${PATH_DIR#${ROOT_DIR%/*}/}${TEMPLATE:+" [${TEMPLATE}"}]${NC}" | sed "s|\/|${SEPARATOR:-/}|g")'
      SEPARATOR="${OPTARG}";;
    D)
      CURRENT_DIR='$(echo "${PREF}${R}${PATH_DIR}${TEMPLATE:+"/ [${TEMPLATE}"}]${NC}" | sed "s|\/|${SEPARATOR:-/}|g")'
      SEPARATOR="${OPTARG}";;
    c)
      CURSOR=' <--[${SELECT}\/${COUNT}]';;
    C)
      CURSOR=' <--[${SELECT}\/${COUNT}] ${LINE_LONG%${LINE_SHORT}}';;
    N)
      NL="$(nl)";;
    s)
      SORT="t";;
    S)
      SORT="S";;
  esac
done

R='\e[0;31m' # красим в красный
NC='\e[0m'   # сбрасываем цвет

F_TYPE="${F_TYPE:-dl-bcps}" # фильтруем список файлов по типам
PATH_DIR="${PATH_DIR:-/}" # определяем начальный каталог
PART_NAME="${PART_NAME:-.*}" # фильтруем список файлов по имени
ROOT_DIR=${ROOT_DIR:-/} # определяем корневой каталог для навигатора 

DEEP=$(($(tput lines)-8-$(${COMMAND_BEFOR} | wc -l))) # рассчитываем высоту видимой области в строках
PREF="   " # определяем префикс перед всеми строками списка
PREF_S="-> " # определяем префикс курсора
SELECT=1 # определяем координаты курсора
TOP=1 # координаты начала видимой области (номер строки)

while true; do
    clear # в начале цикла чистим экран
    ${COMMAND_BEFOR} # добавляем команды перед отрисовкой списка, например, lsblk или echo
    COUNT=$(FList -lA${SORT} "${PATH_DIR}" "${F_TYPE}" "${TEMPLATE}" | wc -l) # считаем количество файлов в каталоге
    LINE_LONG=$(FList -lA${SORT} "${PATH_DIR}" "${F_TYPE}" "${TEMPLATE}" | sed "${SELECT}"'!d') # длинный формат строки под курсором
    LINE_SHORT=$(FList -lAQ${SORT} "${PATH_DIR}" "${F_TYPE}" "${TEMPLATE}" | sed "${SELECT}"'!d') # короткий формат строки под курсором
    eval POST_S="${CURSOR}" # определяем постфикс курсора
    
    eval echo -e "${HELP}" # выводим подсказку управления
    echo
    eval echo -e "${F_SELECTED}" # выводим имя выбранного файла
    echo
    eval echo -e "${CURRENT_DIR}" # выводим текущий путь c шаблоном поиска, если есть
    FList -lAQ${SORT} "${PATH_DIR}" "${F_TYPE}" "${TEMPLATE}" "${PREF}" | sed -r "${SELECT}s|^${PREF}(.*)$|${PREF_S}\1${POST_S}|;${TOP},$((${TOP}+${DEEP}-1))"'!d' # рисуем список
#echo -e "COUNT[${COUNT}] TOP[${TOP}] DEEP[${DEEP}] SELECT[${SELECT}] \nLINE_LONG[${LINE_LONG}] \nLINE_SHORT[${LINE_SHORT}] \nTEMPLATE[$TEMPLATE] ROOT_DIR[$ROOT_DIR]"

    read -s -n1 < /dev/tty # читаем один символ сразу с подтверждением (не нужно Enter жать)
    case $REPLY in

        j) # вниз по списку. Eсли курсор не на последней строке, то (если курсор на последней строке видимой области, то двигаем её на строку вниз) и двигаем курсор на строку вниз
            if [[ ${SELECT} -lt ${COUNT} ]]; then
                [[ ${SELECT} -eq $((${TOP}+${DEEP}-1)) ]] && TOP=$((${TOP}+1))
                SELECT=$((${SELECT}+1)); 
            fi;;
        
        k) # вверх по списку. Если курсор не на 1 строке, то (если курсор на 1 строке видимой области, то двигаем её на строку вверх) и двигаем курсор на строку вверх
            if [[ ${SELECT} -gt 1 ]]; then
                [[ ${SELECT} -eq ${TOP} ]] && TOP=$((${TOP}-1))
                SELECT=$((${SELECT}-1))
            fi;;
        
        h${BLOCK_HL}) # .. Если не в корне, то запоминаем имя текущего "..", режем путь, ищем позицию в новом ".." и ставим туда курсор (если курсор ниже видимой области, то двигаем её), трём шаблон поиска 
            if [[ ${PATH_DIR} != ${ROOT_DIR} ]] ; then
                PARENT=${PATH_DIR##*/}
                PATH_DIR="${PATH_DIR%/*}" && [[ -z ${PATH_DIR} ]] && PATH_DIR="/"
                SELECT=$(FList -lA${SORT} "${PATH_DIR}" "${F_TYPE}" | sed -n "/${PARENT}/=;/${PARENT}/q; d")
                if [[ ${SELECT} -gt ${DEEP} ]]; then
                    TOP=$((${SELECT}-${DEEP}+1))
                else
                    TOP=1
                fi
                TEMPLATE=""
            else
                SELECTED_FILE="${ROOT_DIR}"
            fi;;
        
        l${BLOCK_HL}) # в каталог под курсором. Если директория, то добавляем к пути её имя, курсор и видимую область на 1 строку, трём шаблон поиска
            [[ "${LINE_LONG:0:1}" = "d" ]] && PATH_DIR="${PATH_DIR}/${LINE_SHORT}" && SELECT=1 && TOP=1
            TEMPLATE="";;
        
        /) # / - поиск. Задаёт шаблон поиска в качестве 4 параметра для FList(), который удаляет все строки, где нет этого вхождения
            echo -en "\n${PREF}${R}search: ${NC}"
            read -sei "${TEMPLATE}" TEMPLATE < /dev/tty;;
        
        s) # s - выбрать каталог под курсором, выполнить ряд команд. 
            SELECTED_FILE="${PATH_DIR}/${LINE_SHORT}"
            ${COMMAND_AFTER};;
        
        q) # q - выход. Если шаблон поиска пустой, то трём экран, выводим полное имя файла и выходим, иначе трём шаблон поиска
            if [[ -z ${TEMPLATE} ]]; then 
                clear
                echo ${SELECTED_FILE}
                break
            else
                TEMPLATE=""
            fi;;
    esac
done
